Q1. Write a regular expression to validate a mobile number with the following rules:
	Must start with 6, 7, 8, or 9
	Must contain exactly 10 digits
	
Q2. Write a regular expression to validate an email ID with the following conditions:
	Username part can contain:
	letters (a–z, A–Z)
	digits (0–9)
	special characters: . _ % + -
	Must contain @
	Domain name should contain only letters
	Extension should contain at least 2 letters
	
Q3. Write a regular expression to validate a password with the following rules:
	Minimum 8 characters
	Must contain at least one uppercase letter
	Must contain at least one digit
	
Q4. Write a regular expression to validate a username with these rules:
	Must start with a letter
	Can contain letters, digits, and underscore (_)
	Length should be between 5 and 15 characters
	
Q5. OTP and PIN Code Validation
	(a) OTP Validation
	Write a regular expression to validate a 6-digit OTP.
	(b) PIN Code Validation
	Write a regular expression to validate a 4-digit PIN.
	
Q6. Write a regular expression to validate an Indian vehicle number in the following format:MH12AB1234

Q7. Write a regular expression to validate a date in the format: dd-mm-yyyy










String.matches() can only match the entire string once and does not support searching, multiple matches, 
or reuse of the regex efficiently.

Pattern class :
	Represents a compiled regular expression
	Created once and reused
	Improves performance	
	
Matcher class :
	Applies the pattern to a specific string
	Performs actual operations like:
		find()	
		matches()
		group()
		start() / end()	
EG: 
	
import java.util.regex.*;

public class Demo {
    public static void main(String[] args) {

        Pattern p = Pattern.compile("\\d+");
        Matcher m = p.matcher("Java 123 and 456");

        while (m.find()) {
            System.out.println(m.group());
        }
    }
}
-------------------------------------------------------------------------------------
When should we use Pattern & Matcher?
	Use Pattern & Matcher when:
		Searching inside a string
		Finding multiple matches
		Reusing the same regex many times
		Need start/end positions
	
compile() :
	compile() converts a regex string into a reusable, optimized Pattern object.
	A regex written as a String cannot directly perform matching.
	Java first needs to understand, validate, and optimize that regex.That work is done by compile().

find() :
	find() searches the input string for the next substring that matches the regex pattern.
	present inside Matcher class.	
	
group() :
	group() returns the part of the string that was matched by the regex.
	present inside Matcher class.
	
Eg1: 
	Pattern p = Pattern.compile("\\d+");
	Matcher m = p.matcher("Java 123 and 456");

	while (m.find()) {
 	   System.out.println(m.group());
	}
output : 
	123
	456

Eg2: 

	Pattern p = Pattern.compile("(\\d{2})-(\\d{2})-(\\d{4})");
	Matcher m = p.matcher("DOB: 12-05-2024");

	if (m.find()) {
  	  System.out.println(m.group());    // full match 	12-05-2024
  	  System.out.println(m.group(1));   // first group	12
  	  System.out.println(m.group(2));   // second group	05
  	  System.out.println(m.group(3));   // third group	2024
	}
Eg3 : 
	Pattern p = Pattern.compile("(\\w+)@(\\w+\\.\\w+)");
	Matcher m = p.matcher("mail: test@gmail.com");

	if (m.find()) {
  	  System.out.println("User: " + m.group(1)); // User: test
  	  System.out.println("Domain: " + m.group(2)); // Domain: gmail.com
	}
	
start() :
	start() returns the starting index of the current match in the input string.
	present inside Matcher class.

end() :
	end() returns the index immediately after the last character of the current match.
	present inside Matcher class.
	
	
program to understand all methods.
import java.util.regex.*;

9
Output : 
123
5
8
-----
456
13
16
-----
12
30
32
-----
05
33
35
-----
2024
36
40
-----







..